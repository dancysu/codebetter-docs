# 数组

在 JavaScript中,数组可以容纳任何类型的值,可以是字符串、数字、对象,甚至是其他数组。

```js
let arr = [1, '2', [3]];
```

对数组声明后即可向其中加入值,不需要预先设定大小。

```js
let arr = [];
arr[0] = 1;
```



在使用delete运算符删除数组元素后,数组的length属性并不会发生变化。





数组通过数字进行索引,但有趣的是它们也是对象,所以也可以包含字符串键值和属性（但这些并不计算在数组长度内）

```js
let arr = []
arr[0] = 1
arr['foo'] = 'foo'
arr.length // 1
arr['foo'] // 'foo'
arr.foo = 'foo'
```

注意：如果字符串键值能够被强制类型转换为十进制的话,它就会被当作数字索引来处理。

```js
let arr = []

arr['12'] = 12
arr.length // 12
```

在数组中加入字符串键值/属性并不是一个好主意。建议使用对象来存放键值/属性值,用数组来存放数字索引值。







## 稀疏数组

含有空白或空缺单元的数组。





## 类数组

类数组并非真正意义上的数组





### 数组

数组（Array）是一种可以按顺序保存多个数据的集合,属于**对象类型**的一种,数组是有长度的。

#### 声明语法

```javascript
1. 使用构造函数声明数组
let arr = new Array()

注意：
	构造函数内只有一个参数,则表示数组的长度
  let arr = new Array(10)  //数组的长度是10
  如果输入多个参数则表示数组的初始化
  let arr = new Array(10,'小苏',20)


2. []
let 数组名 = [数据1,数据2,数据3,…,数据n]

例：let names = ['小明','小刚','小红','小丽','小米']
```

- 数组是按顺序保存,所以每个数据都有自己的编号
- 计算机中的编号从0开始（索引、下标）
- 在数组中,数据的编号也叫索引或下标
- **数组可以存储任意类型的数据**

#### 赋值语法

```javascript
数组名[下标] = 值

例如：
	let arr = []
	arr[0] = '小苏'
	arr[1] = '小旭'

如果想修改数组的值,找对应的索引重新赋值即可。
	arr[0] = '小苏同学'
```

#### 取值语法

```javascript
数组名[下标]

例如：
	//取值小苏
	let arr = ['小苏','小旭']
	console.log(arr[0])
```



# 数组函数

## Array.at()

**`at() `** 方法接收一个整数值并返回该索引的项目,允许正数和负数。负整数从数组中的最后一个项目开始倒数。

```js
let arr = ["钢铁侠", "蜘蛛侠", "黑豹", "绿巨人"];
let index = 2;
console.log(arr.at(index)); // 黑豹
index = -2;
console.log(arr.at(index)); // 黑豹
```

## Array.concat()

**`concat()`** 方法用于合并两个或多个数组。

此方法不会更改现有数组,而是返回一个新数组。

```js
const array1 = ['a', 'b', 'c'];
const array2 = ['d', 'e', 'f'];
const array3 = array1.concat(array2);

console.log(array3);
```

## Array.copyWithin()

**`copyWithin()`** 方法浅复制数组的一部分到同一数组中的另一个位置,并返回它,不会改变原数组的长度。

返回值：改变后的数组

```js
const array1 = ['a', 'b', 'c', 'd', 'e'];

// copy to index 0 the element at index 3
console.log(array1.copyWithin(0, 3, 4));
// expected output: Array ["d", "b", "c", "d", "e"]

// copy to index 1 all elements from index 3 to the end
console.log(array1.copyWithin(1, 3));
// expected output: Array ["d", "d", "e", "d", "e"]
```

## Array.entries()

**`entries()`** 方法返回一个新的 **Array Iterator** 对象,该对象包含数组中每个索引的键/值对。

## Array.every()

**`every()`** 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。

若收到一个空数组,此方法在任何情况下都会返回 `true`。

```js
const isBelowThreshold = (currentValue) => currentValue < 40;

const array1 = [1, 30, 39, 29, 10, 13];

console.log(array1.every(isBelowThreshold));
// expected output: true
```

## Array.fill()

**`fill()`** 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。

```js
const array1 = [1, 2, 3, 4];

// fill with 0 from position 2 until position 4
console.log(array1.fill(0, 2, 4));
// expected output: [1, 2, 0, 0]

// fill with 5 from position 1
console.log(array1.fill(5, 1));
// expected output: [1, 5, 5, 5]

console.log(array1.fill(6));
// expected output: [6, 6, 6, 6]
```

## Array.filter()

**`filter()`** 方法创建给定数组一部分的浅拷贝,其包含通过所提供函数实现的测试的所有元素。

```js
const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];

const result = words.filter(word => word.length > 6);

console.log(result);
```

## Array.find()

**`find()`** 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 `undefined`。

```js
const array1 = [5, 12, 8, 130, 44];

const found = array1.find(element => element > 10);

console.log(found);
```

## Array.findIndex()

**`findIndex()`方法返回数组中满足提供的测试函数的第一个元素的索引**。若没有找到对应元素则返回-1。

```js
const array1 = [5, 12, 8, 130, 44];
const isLargeNumber = (element) => element > 13;
console.log(array1.findIndex(isLargeNumber));
```

## Array.findLast()

**`findLast()`** 方法返回数组中满足提供的测试函数条件的最后一个元素的值。如果没有找到对应元素,则返回 `undefined`。

```js
const array1 = [5, 12, 50, 130, 44];

const found = array1.findLast((element) => element > 45);

console.log(found);
// expected output: 130
```

## Array.findLastIndex()

**`findLastIndex()`** 方法返回数组中满足提供的测试函数条件的最后一个元素的索引。若没有找到对应元素,则返回 -1。

```js
const array1 = [5, 12, 50, 130, 44];

const isLargeNumber = (element) => element > 45;

console.log(array1.findLastIndex(isLargeNumber));
```

## Array.flat()

**`flat()`** 方法会按照一个可指定的深度递归遍历数组,并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。

```js
const arr1 = [0, 1, 2, [3, 4]];

console.log(arr1.flat());
// expected output: [0, 1, 2, 3, 4]

const arr2 = [0, 1, 2, [[[3, 4]]]];

console.log(arr2.flat(2));
```

## Array.flatMap()

**`flatMap()`** 方法首先使用映射函数映射每个元素,然后将结果压缩成一个新数组。它与 map 连着深度值为 1 的 flat 几乎相同,但 `flatMap` 通常在合并成一种方法的效率稍微高一些。

```js
const arr1 = [1, 2, [3], [4, 5], 6, []];

const flattened = arr1.flatMap(num => num);

console.log(flattened);
// expected output: Array [1, 2, 3, 4, 5, 6]
```

## Array.forEach()

遍历数组

```js
let fruits = ['Apple', 'Banana']
fruits.forEach(function(item, index, array) {
  console.log(item, index)
})
// Apple 0
// Banana 1
```

## Array.from()

**`forEach()`** 方法对数组的每个元素执行一次给定的函数。

```js
const array1 = ['a', 'b', 'c'];

array1.forEach(element => console.log(element));

// expected output: "a"
// expected output: "b"
// expected output: "c"
```

## Array.group()

**`Array.from()`** 方法对一个类似数组或可迭代对象创建一个新的,浅拷贝的数组实例。

```js
console.log(Array.from('foo'));
// expected output: Array ["f", "o", "o"]

console.log(Array.from([1, 2, 3], x => x + x));
// expected output: Array [2, 4, 6]
```

## Array.includes()

**`includes()`** 方法用来判断一个数组是否包含一个指定的值,根据情况,如果包含则返回 `true`,否则返回 `false`。

```js
let arr = ["钢铁侠", "蜘蛛侠", "黑豹", "绿巨人"];
let res = arr.includes("钢铁侠");
console.log(res);	// true
```

## Array.indexOf()

检测当前值在数组中第一次出现的位置索引

返回值：第一次查到的索引,未找到返回-1。

```js
let arr = ["钢铁侠", "蜘蛛侠", "黑豹", "绿巨人"];
let res = arr.indexOf("钢铁侠");
console.log(res);	// 0
```

## Array.isArray()

**`Array.isArray()`** 用于确定传递的值是否是一个 `Array`。

```js
Array.isArray([1, 2, 3]);  // true
Array.isArray({foo: 123}); // false
Array.isArray('foobar');   // false
Array.isArray(undefined);  // false
```

## Array.join()

**`join()`** 方法将一个数组（或一个[类数组对象](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Indexed_collections#working_with_array-like_objects)）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目,那么将返回该项目而不使用分隔符。

```js
const elements = ['Fire', 'Air', 'Water'];

console.log(elements.join());
// expected output: "Fire,Air,Water"

console.log(elements.join(''));
// expected output: "FireAirWater"

console.log(elements.join('-'));
// expected output: "Fire-Air-Water"
```

## Array.keys()

**`keys()`** 方法返回一个包含数组中每个索引键的 **`Array Iterator`** 对象。

```js
const array1 = ['a', 'b', 'c'];
const iterator = array1.keys();

for (const key of iterator) {
  console.log(key);
}

// expected output: 0
// expected output: 1
// expected output: 2
```

## Array.lastIndexOf()

**`lastIndexOf()`** 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引,如果不存在则返回 -1。从数组的后面向前查找,从 `fromIndex` 处开始。

```js
const animals = ['Dodo', 'Tiger', 'Penguin', 'Dodo'];

console.log(animals.lastIndexOf('Dodo'));
// expected output: 3

console.log(animals.lastIndexOf('Tiger'));
// expected output: 1
```

## Array.map()

**`map()`** 方法创建一个新数组,这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。

```js
const array1 = [1, 4, 9, 16];
// pass a function to map
const map1 = array1.map(x => x * 2);
console.log(map1);
// expected output: Array [2, 8, 18, 32]
```

## Array.of()

**`Array.of()`** 方法创建一个具有可变数量参数的新数组实例,而不考虑参数的数量或类型。

**`Array.of()`** 和 **`Array`** 构造函数之间的区别在于处理整数参数：**`Array.of(7)`** 创建一个具有单个元素 **7** 的数组,而 **`Array(7)`** 创建一个长度为 7 的空数组（**注意**：这是指一个有 7 个空位 (empty) 的数组,而不是由 7 个`undefined`组成的数组）。

```js
Array.of(7); // [7]
Array(7); // array of 7 empty slots

Array.of(1, 2, 3); // [1, 2, 3]
Array(1, 2, 3);    // [1, 2, 3]
```

## Array.pop()

**`pop()`** 方法从数组中删除最后一个元素,并返回该元素的值。此方法会更改数组的长度。

```js
let fruits = ['Apple', 'Banana']
let last = fruits.pop() // remove Orange (from the end)
// ["Apple", "Banana"]
```

## Array.push()

**`push()`** 方法将一个或多个元素添加到数组的末尾,并返回该数组的新长度。

```js
let fruits = ['Apple', 'Banana']
let newLength = fruits.push('Orange')
// ["Apple", "Banana", "Orange"]
```

## Array.reduce()

**`reduce()`** 方法对数组中的每个元素按序执行一个由您提供的 **reducer** 函数,每一次运行 **reducer** 会将先前元素的计算结果作为参数传入,最后将其结果汇总为单个返回值。

```js
const array1 = [1, 2, 3, 4];

// 0 + 1 + 2 + 3 + 4
const initialValue = 0;
const sumWithInitial = array1.reduce(
  (previousValue, currentValue) => previousValue + currentValue,
  initialValue
);

console.log(sumWithInitial);
// expected output: 10
```

## Array.reduceRight()

**`reduceRight()`** 方法接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值。

```js
const array1 = [[0, 1], [2, 3], [4, 5]];

const result = array1.reduceRight((accumulator, currentValue) => accumulator.concat(currentValue));

console.log(result);
// expected output: Array [4, 5, 2, 3, 0, 1]
```

## Array.reverse()

**`reverse()`** 方法将数组中元素的位置颠倒,并返回该数组。数组的第一个元素会变成最后一个,数组的最后一个元素变成第一个。该方法会改变原数组。

```js
let arr = ["钢铁侠", "蜘蛛侠", "黑豹", "绿巨人"];
arr.reverse();
console.log(arr);
// (4) ['绿巨人', '黑豹', '蜘蛛侠', '钢铁侠']
```

## Array.shift()

**`shift()`** 方法从数组中删除**第一个**元素,并返回该元素的值。此方法更改数组的长度。

```js
let fruits = ['Apple', 'Banana']
let first = fruits.shift() // remove Apple from the front
// ["Banana"]
```

## Array.slice()

**`slice()`** 方法返回一个新的数组对象,这一对象是一个由 `begin` 和 `end` 决定的原数组的**浅拷贝**（包括 `begin`,不包括`end`）。原始数组不会被改变。

```js
let shallowCopy = fruits.slice() // this is how to make a copy
// ["Strawberry", "Mango"]
```

## Array.some()

**`some()`** 方法测试数组中是不是至少有 1 个元素通过了被提供的函数测试。它返回的是一个 Boolean 类型的值。

```js
const array = [1, 2, 3, 4, 5];

// checks whether an element is even
const even = (element) => element % 2 === 0;

console.log(array.some(even));
// expected output: true
```

## Array.sort()

**`sort()`** 方法用原地算法对数组的元素进行排序,并返回数组。默认排序顺序是在将元素转换为字符串,然后比较它们的 UTF-16 代码单元值序列时构建的

由于它取决于具体实现,因此无法保证排序的时间和空间复杂性。

```js
const months = ['March', 'Jan', 'Feb', 'Dec'];
months.sort();
console.log(months);
// expected output: Array ["Dec", "Feb", "Jan", "March"]

const array1 = [1, 30, 4, 21, 100000];
array1.sort();
console.log(array1);
// expected output: Array [1, 100000, 21, 30, 4]
```

## Array.splice()

**`splice()`** 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。**此方法会改变原数组**。

```js
const months = ['Jan', 'March', 'April', 'June'];
months.splice(1, 0, 'Feb');
// inserts at index 1
console.log(months);
// expected output: Array ["Jan", "Feb", "March", "April", "June"]

months.splice(4, 1, 'May');
// replaces 1 element at index 4
console.log(months);
// expected output: Array ["Jan", "Feb", "March", "April", "May"]

```

## Array.toLocaleString()

**`toLocaleString()`** 返回一个字符串表示数组中的元素。数组中的元素将使用各自的 `toLocaleString` 方法转成字符串,这些字符串将使用一个特定语言环境的字符串（例如一个逗号 ","）隔开。

```js
const array1 = [1, 'a', new Date('21 Dec 1997 14:12:00 UTC')];
const localeString = array1.toLocaleString('en', { timeZone: 'UTC' });

console.log(localeString);
```

## Array.toString()

**`toString()`** 方法返回一个字符串,表示指定的数组及其元素。

```js
const array1 = [1, 2, 'a', '1a'];

console.log(array1.toString());
```

## Array.unshift()

**`unshift()`** 方法将一个或多个元素添加到数组的**开头**,并返回该数组的**新长度**。

```js
const array1 = [1, 2, 3];

console.log(array1.unshift(4, 5));
// expected output: 5

console.log(array1);
// expected output: Array [4, 5, 1, 2, 3]
```

## Array.values()

**`values()`** 方法返回一个新的 **`Array Iterator`** 对象,该对象包含数组每个索引的值。

```js
const array1 = ['a', 'b', 'c'];
const iterator = array1.values();

for (const value of iterator) {
  console.log(value);
}
```

